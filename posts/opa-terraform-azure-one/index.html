<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Enforcing OPA policies with Terraform / OpenTofu in network-isolated Azure VNet - Part 1 | Tommaso Colella | SWE</title>
<meta name=keywords content><meta name=description content="Recently, we had a couple of naming-related incidents at work. We respect certain naming conventions, but sometimes errors slip into our Terraform infrastructure&rsquo;s code, and remediation may be costly.
I had to find a way to simplify resource naming policy enforcement: at first, I thought about using Git Hooks (with a custom HCL parser) or local linters. Both of these approaches came with downsides that would make it unpractical to employ them on multiple repositories: first of all, the necessity to set up hooks or linter configurations in each repo."><meta name=author content="Tommaso Colella"><link rel=canonical href=https://gioleppe.github.io/posts/opa-terraform-azure-one/><meta name=google-site-verification content="G-JHDYWZPGQF"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://gioleppe.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://gioleppe.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://gioleppe.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://gioleppe.github.io/apple-touch-icon.png><link rel=mask-icon href=https://gioleppe.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://gioleppe.github.io/posts/opa-terraform-azure-one/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/ld+json>{"@context":"https://schema.org/","@type":"Person","name":"Tommaso Colella","url":"https://gioleppe.github.io/","image":"https://media.licdn.com/dms/image/C5603AQEo-0VsShX7eg/profile-displayphoto-shrink_400_400/0/1612869300096?e=1676505600&v=beta&t=C0ZDSUriW6h0wK3Py6DoZ8viruvCLJdTg99jQCGsl9Y","sameAs":["https://www.linkedin.com/in/tommaso-colella-051012143/","https://github.com/gioleppe","https://www.facebook.com/amuchina"],"jobTitle":"Software Engineer","worksFor":{"@type":"Organization","name":"YOOX Net-a-Porter Group S.p.A"}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JHDYWZPGQF"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JHDYWZPGQF",{anonymize_ip:!1})}</script><meta property="og:title" content="Enforcing OPA policies with Terraform / OpenTofu in network-isolated Azure VNet - Part 1"><meta property="og:description" content="Recently, we had a couple of naming-related incidents at work. We respect certain naming conventions, but sometimes errors slip into our Terraform infrastructure&rsquo;s code, and remediation may be costly.
I had to find a way to simplify resource naming policy enforcement: at first, I thought about using Git Hooks (with a custom HCL parser) or local linters. Both of these approaches came with downsides that would make it unpractical to employ them on multiple repositories: first of all, the necessity to set up hooks or linter configurations in each repo."><meta property="og:type" content="article"><meta property="og:url" content="https://gioleppe.github.io/posts/opa-terraform-azure-one/"><meta property="og:image" content="https://gioleppe.github.io/images/opa-gavel-cropped.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-06T00:27:25+00:00"><meta property="article:modified_time" content="2024-03-06T00:27:25+00:00"><meta property="og:site_name" content="Tommaso Colella"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://gioleppe.github.io/images/opa-gavel-cropped.jpg"><meta name=twitter:title content="Enforcing OPA policies with Terraform / OpenTofu in network-isolated Azure VNet - Part 1"><meta name=twitter:description content="Recently, we had a couple of naming-related incidents at work. We respect certain naming conventions, but sometimes errors slip into our Terraform infrastructure&rsquo;s code, and remediation may be costly.
I had to find a way to simplify resource naming policy enforcement: at first, I thought about using Git Hooks (with a custom HCL parser) or local linters. Both of these approaches came with downsides that would make it unpractical to employ them on multiple repositories: first of all, the necessity to set up hooks or linter configurations in each repo."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gioleppe.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Enforcing OPA policies with Terraform / OpenTofu in network-isolated Azure VNet - Part 1","item":"https://gioleppe.github.io/posts/opa-terraform-azure-one/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Enforcing OPA policies with Terraform / OpenTofu in network-isolated Azure VNet - Part 1","name":"Enforcing OPA policies with Terraform \/ OpenTofu in network-isolated Azure VNet - Part 1","description":"Recently, we had a couple of naming-related incidents at work. We respect certain naming conventions, but sometimes errors slip into our Terraform infrastructure\u0026rsquo;s code, and remediation may be costly.\nI had to find a way to simplify resource naming policy enforcement: at first, I thought about using Git Hooks (with a custom HCL parser) or local linters. Both of these approaches came with downsides that would make it unpractical to employ them on multiple repositories: first of all, the necessity to set up hooks or linter configurations in each repo.","keywords":[],"articleBody":"Recently, we had a couple of naming-related incidents at work. We respect certain naming conventions, but sometimes errors slip into our Terraform infrastructure‚Äôs code, and remediation may be costly.\nI had to find a way to simplify resource naming policy enforcement: at first, I thought about using Git Hooks (with a custom HCL parser) or local linters. Both of these approaches came with downsides that would make it unpractical to employ them on multiple repositories: first of all, the necessity to set up hooks or linter configurations in each repo.\nThat‚Äôs when I discovered Open Policy Agent (OPA). Integrating OPA into our CI-CD and centralizing shared policies in an Azure Repository would make enforcing trivial. I decided the approach was worth trying and drafted an adoption plan.\nThe main complication in our setup lies in the network architecture: our resources are network-isolated, so we have to use dedicated Azure Pipelines Agents to provision our infrastructure.\nRead this two-article series to see how OPA integrates with Azure DevOps and a network-isolated self-hosted pipeline agent. I will start by quickly going over OPA.\nOPA and Policy as Code OPA is an open-source, vendor-agnostic policy engine. It is a CNCF graduate project and can be adapted to work in many different use cases and situations: in particular, it can be run both as a CLI tool or as a REST server.\nOPA lets you define policies with a specialized domain-specific language called Rego. You can test JSON structured data describing your domain against these policies, assessing compliance, and providing actionable messages in case of violation.\nüí°I know there are a couple of alternatives to OPA, first of all, the Azure Policy service, but I wanted to be as vendor-agnostic as possible, and I always prefer open-source tools such as OPA when they are available. You can employ OPA and Rego on numerous domains, even other than Infrastructure as Code. There‚Äôs also a good Rego extension for writing policies in Visual Studio Code by one of the authors of OPA, Torin Sandall, and a brand new Rego linter made by Styra, the company maintaining OPA.\nThe Rego language is an example of Policy as Code: you write policies in a regular language that is unambiguous and easy to enforce automatically, using tools such as OPA. In my opinion, Policy as Code will bring a lot of value to organizations that have already invested in IaC and DevOps practices in general: automating policy compliance assessment across a wide variety of domains (in a vendor-agnostic way) will eventually help those organizations succeed, and I could imagine ‚ÄúPolicyOps‚Äù teams in a not-too-far-future.\nThe following is a simple example of a Rego policy in which we test if a user is old enough. In the affirmative case, we allow the action. We also allow the action if it comes from a user called Ada.\npackage old_enough import rego.v1 # By default our user is not old enough, and not allowed default allow := false default user_is_old_enough := false # Allow if the user is old enough allow if user_is_old_enough # OR allow if the user is called Ada allow if { input.user == \"Ada\" } # user_is_old_enough is true if the user we input is in our data, and its age is \u003e= 18 user_is_old_enough if { data.users[input.user] \u003e 18 } We also create a policy_data.json with a list of users and an input.json file with the user we evaluate our policies against. In our small example, the files are as follows:\n# input.json { \"user\": \"Hedy\" } # policy_data.json { \"users\": { \"Hedy\": 42, \"Ada\": 11 } } So, we are checking if Hedy is old enough by querying the old_enough policy. We pass OPA her name and a list of policy-associated users as input.\nTo do this, we can use the opa eval command:\n‚ûú opa eval -i input.json -d not_old_enough.rego -d policy_data.json \"data.old_enough\" Which produces the following output:\n{ \"result\": [ { \"expressions\": [ { \"value\": { \"allow\": true, \"user_is_old_enough\": true }, \"text\": \"data.old_enough\", \"location\": { \"row\": 1, \"col\": 1 } } ] } ] } Indeed, Hedy is old enough, so she is allowed as well.\nIn-depth exploration of Rego and OPA is outside the scope of this article. You can check the official documentation if you are interested in learning more. It suffices to say that we will use the opa exec command instead of opa eval because it is the intended way to run OPA in one shot.\nNow, let‚Äôs jump to our Azure DevOps example!\nOPA usage over network-isolated infrastructure Let‚Äôs have a quick look at our deployed infrastructure:\nLet‚Äôs have a quick look at our deployed infrastructure: In this slightly simplified version of the infrastructure I‚Äôm dealing with at work, we have a network-isolated Virtual Network, which comprises a series of subnets that may communicate with each other.\nThe Virtual Network has a dedicated self-hosted Azure Pipelines Agent used to deploy infrastructure over the network-isolated part of the Azure Cloud. The agent is inside a subnet as well. I didn‚Äôt represent it in the image for simplicity.\nüí° We are dealing with a high-security environment ‚Äì that‚Äôs why we have a dedicated Azure Pipelines agent for our isolated virtual network. Without it, we would have no visibility into our services: it would be impossible to perform most operations on them, including deployments.\nWe want to store our policies where our agents can easily access them. We are going to use Azure DevOps for this:\nThere is a reason I drew dotted lines towards Docker and the Azure Storage Account: we can either store the OPA binary into a purposely-made storage account or run a Docker image to use the CLI tool. I left out the possibility of downloading the binary from Styra‚Äôs website on purpose: if we are allowed access to the public Internet, the docker image is more ergonomic. We are already using Docker on other steps of our Azure Pipeline, so we chose to continue doing so.\nüí° In most cases, this kind of choice depends on the architectural requirements of the infrastructure (which may comprise strict security requirements). Some organizations may restrict access to public docker registries, so the storage account method should be the most secure.\nThe following flowchart diagram describes the steps of our OPA-augmented provisioning pipeline:\nPreparing a Terraform plan to test our policy against Now that we have a clear path, it‚Äôs time to write the policies. We will start by using this simple Terraform code that creates some resources.\n#Azure resource group resource \"azurerm_resource_group\" \"rg\" { name = var.rg_name location = var.location } #Azure storage account resource \"azurerm_storage_account\" \"sa\" { name = var.sa_name resource_group_name = azurerm_resource_group.rg.name location = azurerm_resource_group.rg.location account_tier = \"Standard\" account_replication_type = \"LRS\" } #Azure app service plan resource \"azurerm_service_plan\" \"sp\" { sku_name = \"Y1\" location = azurerm_resource_group.rg.location name = var.app_service_plan_name resource_group_name = azurerm_resource_group.rg.name os_type = \"Linux\" } resource \"azurerm_linux_function_app\" \"fap\" { for_each = var.fap_names name = each.key location = azurerm_resource_group.rg.location resource_group_name = azurerm_resource_group.rg.name service_plan_id = azurerm_service_plan.sp.id storage_account_name = azurerm_storage_account.sa.name storage_account_access_key = azurerm_storage_account.sa.primary_access_key site_config { } } We are mainly interested in the Function Apps provisioned by the azurerm_linux_function_app resource. After initializing Terraform, we can use the terraform plan --out=functions.tfplan command to generate the binary execution plan, and then we can transform it to JSON by using terraform show -json .\\functions.tfplan \u003e functions.json. We are ready to write a simple naming convention policy and employ it in our plan.\nüí° I‚Äôm referring to Terraform since that is what I‚Äôm using at work, but the steps are 100% compatible with OpenTofu, and I highly recommend you check out the project. I‚Äôm using OpenTofu in place of Terraform for all my private stuff.\nWriting a naming convention Policy for Function Apps Having decided how to run our policy evaluation, we can proceed by writing a naming convention policy. I will start with a simple one. The plan is to grow the scope of the policies as I get more confidence with the Rego language.\nI decided to start with a simple naming convention rule that applies to Function Apps:\nThe name must always start with ‚Äúfap-‚Äù which stands for Function App, The name must always contain the three-letter abbreviation of the specific project stream we are considering. For the sake of this example, we will go with ‚Äú-prj-‚Äù After watching this tutorial on integrating Terraform and OPA, I decided to use some of the proposed utility functions, which you can find in the repo accompanying the video. In particular, I‚Äôm using the get_resources_by_type utility function to filter out the resources in the Terraform plan for further analysis:\npackage terraform.plan_functions import rego.v1 # Get resources by type get_resources_by_type(type, resources) = filtered_resources { filtered_resources := [resource | resource := resources[_]; resource.type = type] } I placed the helper functions in the terraform_functions.rego file.\nüí° A keen eye should spot a minor difference compared to the code in the repo: I‚Äôve changed the ‚Äúimport future.keywords‚Äù statement with import rego.v1. This by purpose: according to the official documentation using import rego.v1 will ensure keyword compatibility with OPA 1.0 when it releases, thus future-proofing our policies. It‚Äôs also good to spread best practices such as this one.\nNow that we have some helper functions, we can create another file, naming_policies.rego:\npackage general.production import rego.v1 import data.general.naming_conventions import data.general.plan_functions import input.resource_changes # (1) # Check to see if Function App is using the correct naming convention linux_faps := plan_functions.get_resources_by_type(\"azurerm_linux_function_app\", resource_changes) # (2) check_fap_naming_convention(fap) if { name := fap.change.after.name startswith(name, \"fap-\") contains(name, \"-prj-\") } # (3) incorrect_naming_convention(resource_checks) = resources if { resources := [resource | resource := resource_checks[_] not check_fap_naming_convention(resource) ] (4) } deny contains msg if { resources := incorrect_naming_convention(linux_faps) resources != [] msg := sprintf(\"The following function app violates the naming convention: %s\", [resources[_].address]) } (5) I‚Äôll quickly go over the code: we start by importing the resource_changes object from our JSON-formatted Terraform plan (1) that we pass as input, and then we extract all Linux-based function apps by using the get_resources_by_type helper function (2). After that, we define a check_fap_naming_convention helper function (3) and use it in a comprehension inside the incorrect_naming_convention rule (4). The comprehension evaluates to the filtered array of resources which are not following our naming convention. Finally, we define a deny rule that generates the set of error messages, in case some of our Function Apps violate the naming convention (5). Note that the message includes the Terraform address of the resource (e.g. azurerm_linux_function_app.my_fap) to locate it in our Terraform code.\nDon‚Äôt worry if the code feels slightly difficult: declarative languages may seem daunting at first, but in the end, it‚Äôs just data manipulation. I‚Äôm getting used to the Rego language, and I‚Äôm pretty sure my code is still not idiomatic.\nI placed all the rego files inside the policies folder. I will pass its path as a bundle to the OPA CLI. Now it‚Äôs time to test our policy by running opa exec locally.\nRunning the policy locally If you‚Äôve been following along, you should already have a functions.json plan file on which we can try to enforce our policies. In my case, I‚Äôve generated a plan by passing the following value to the fap_names variable:\nfap_names = [ \"fap-prj-one\", \"fap-bad-two\", \"bad-prj-three\" ] Functions two and three would violate the naming convention. Let‚Äôs see our policy bundle in action.\nRunning the opa exec --bundle .\\general_policies\\ --decision general/production/deny .\\functions.json command produces the following output:\n{ \"result\": [ { \"path\": \".\\\\functions.json\", \"result\": [ \"The following function app violates the naming convention: azurerm_linux_function_app.fap[\\\"bad-prj-three\\\"]\", \"The following function app violates the naming convention: azurerm_linux_function_app.fap[\\\"fap-bad-two\\\"]\" ] } ] } The policy works! We still have to integrate it with an Azure DevOps pipeline running on a self-hosted agent. I will do that in the second part of the article, so stay tuned.\nThank you for coming this far. Power to the nerds!\nReferences Open Policy Agent\nOpen Policy Agent - Visual Studio Marketplace\nStyraInc/regal: Regal is a linter for Rego, with the goal of making your Rego magnificent! (github.com)\nOpen Policy Agent | Documentation\nOpen Policy Agent and Terraform - Using opa exec to Evaluate Policies Against an Execution Plan (youtube.com)\n","wordCount":"2024","inLanguage":"en","image":"https://gioleppe.github.io/images/opa-gavel-cropped.jpg","datePublished":"2024-03-06T00:27:25Z","dateModified":"2024-03-06T00:27:25Z","author":{"@type":"Person","name":"Tommaso Colella"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gioleppe.github.io/posts/opa-terraform-azure-one/"},"publisher":{"@type":"Organization","name":"Tommaso Colella | SWE","logo":{"@type":"ImageObject","url":"https://gioleppe.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gioleppe.github.io/ accesskey=h title="Tommaso Colella | SWE (Alt + H)">Tommaso Colella | SWE</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://gioleppe.github.io/about title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gioleppe.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://gioleppe.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Enforcing OPA policies with Terraform / OpenTofu in network-isolated Azure VNet - Part 1</h1><div class=post-meta><span title='2024-03-06 00:27:25 +0000 UTC'>March 6, 2024</span>&nbsp;¬∑&nbsp;10 min&nbsp;¬∑&nbsp;Tommaso Colella</div></header><figure class=entry-cover><img loading=eager src=https://gioleppe.github.io/images/opa-gavel-cropped.jpg alt="Picture of a gavel"><p>Picture by <a href=https://unsplash.com/@tingeyinjurylawfirm>Tingey Injury Law Firm</a> on Unsplash</p></figure><div class=post-content><p>Recently, we had a couple of naming-related incidents at work. We respect certain naming conventions, but sometimes errors slip into our Terraform infrastructure&rsquo;s code, and remediation may be costly.</p><p>I had to find a way to simplify resource naming policy enforcement: at first, I thought about using Git Hooks (with a custom HCL parser) or local linters. Both of these approaches came with downsides that would make it unpractical to employ them on multiple repositories: first of all, the necessity to set up hooks or linter configurations in each repo.</p><p>That&rsquo;s when I discovered <a href=https://www.openpolicyagent.org/>Open Policy Agent</a> (OPA). Integrating OPA into our CI-CD and centralizing shared policies in an Azure Repository would make enforcing trivial. I decided the approach was worth trying and drafted an adoption plan.</p><p>The main complication in our setup lies in the network architecture: our resources are network-isolated, so we have to use dedicated Azure Pipelines Agents to provision our infrastructure.</p><p>Read this two-article series to see how OPA integrates with Azure DevOps and a network-isolated self-hosted pipeline agent. I will start by quickly going over OPA.</p><hr><h3 id=opa-and-policy-as-code>OPA and Policy as Code<a hidden class=anchor aria-hidden=true href=#opa-and-policy-as-code>#</a></h3><p>OPA is an open-source, vendor-agnostic policy engine. It is a CNCF graduate project and can be adapted to work in many different use cases and situations: in particular, it can be run both as a CLI tool or as a REST server.</p><p>OPA lets you define policies with a specialized domain-specific language called Rego. You can test JSON structured data describing your domain against these policies, assessing compliance, and providing actionable messages in case of violation.</p><blockquote><p>üí°I know there are a couple of alternatives to OPA, first of all, the Azure Policy service, but I wanted to be as vendor-agnostic as possible, and I always prefer open-source tools such as OPA when they are available. You can employ OPA and Rego on numerous domains, even other than Infrastructure as Code. There&rsquo;s also a good Rego <a href="https://marketplace.visualstudio.com/items?itemName=tsandall.opa">extension</a> for writing policies in Visual Studio Code by one of the authors of OPA, Torin Sandall, and a brand new Rego <a href=https://github.com/StyraInc/regal>linter</a> made by Styra, the company maintaining OPA.</p></blockquote><p>The Rego language is an example of Policy as Code: you write policies in a regular language that is unambiguous and easy to enforce automatically, using tools such as OPA. In my opinion, Policy as Code will bring a lot of value to organizations that have already invested in IaC and DevOps practices in general: automating policy compliance assessment across a wide variety of domains (in a vendor-agnostic way) will eventually help those organizations succeed, and I could imagine &ldquo;PolicyOps&rdquo; teams in a not-too-far-future.</p><p>The following is a simple example of a Rego policy in which we test if a user is old enough. In the affirmative case, we allow the action. We also allow the action if it comes from a user called Ada.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>package</span> <span class=n>old_enough</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>rego.v1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># By default our user is not old enough, and not allowed</span>
</span></span><span class=line><span class=cl><span class=n>default</span> <span class=n>allow</span> <span class=o>:=</span> <span class=n>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>default</span> <span class=n>user_is_old_enough</span> <span class=o>:=</span> <span class=n>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Allow if the user is old enough</span>
</span></span><span class=line><span class=cl><span class=n>allow</span> <span class=k>if</span> <span class=n>user_is_old_enough</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># OR allow if the user is called Ada</span>
</span></span><span class=line><span class=cl><span class=n>allow</span> <span class=k>if</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nb>input</span><span class=o>.</span><span class=n>user</span> <span class=o>==</span> <span class=s2>&#34;Ada&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># user_is_old_enough is true if the user we input is in our data, and its age is &gt;= 18</span>
</span></span><span class=line><span class=cl><span class=n>user_is_old_enough</span> <span class=k>if</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>data</span><span class=o>.</span><span class=n>users</span><span class=p>[</span><span class=nb>input</span><span class=o>.</span><span class=n>user</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>18</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We also create a policy_data.json with a list of users and an input.json file with the user we evaluate our policies against. In our small example, the files are as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=err>#</span> <span class=err>input.json</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;user&#34;</span><span class=p>:</span> <span class=s2>&#34;Hedy&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>#</span> <span class=err>policy_data.json</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;users&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;Hedy&#34;</span><span class=p>:</span> <span class=mi>42</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;Ada&#34;</span><span class=p>:</span> <span class=mi>11</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>So, we are checking if Hedy is old enough by querying the <em>old_enough</em> policy. We pass OPA her name and a list of policy-associated users as input.</p><p>To do this, we can use the opa eval command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>‚ûú  opa <span class=nb>eval</span> -i input.json -d not_old_enough.rego -d policy_data.json <span class=s2>&#34;data.old_enough&#34;</span>
</span></span></code></pre></div><p>Which produces the following output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;result&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;expressions&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;value&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;allow&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;user_is_old_enough&#34;</span><span class=p>:</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>          <span class=p>},</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;text&#34;</span><span class=p>:</span> <span class=s2>&#34;data.old_enough&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;location&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;row&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;col&#34;</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>          <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Indeed, Hedy is old enough, so she is allowed as well.</p><p>In-depth exploration of Rego and OPA is outside the scope of this article. You can check the <a href=https://www.openpolicyagent.org/docs/latest/>official documentation</a> if you are interested in learning more. It suffices to say that we will use the opa exec command instead of opa eval because it is the intended way to run OPA in <a href=https://www.openpolicyagent.org/docs/latest/cli/#synopsis-6>one shot</a>.</p><p>Now, let&rsquo;s jump to our Azure DevOps example!</p><hr><h3 id=opa-usage-over-network-isolated-infrastructure><strong>OPA usage over network-isolated infrastructure</strong><a hidden class=anchor aria-hidden=true href=#opa-usage-over-network-isolated-infrastructure>#</a></h3><p>Let&rsquo;s have a quick look at our deployed infrastructure:</p><p><img loading=lazy src=images/opa-infra.png alt=opa-infra></p><p>Let&rsquo;s have a quick look at our deployed infrastructure:
In this slightly simplified version of the infrastructure I&rsquo;m dealing with at work, we have a network-isolated Virtual Network, which comprises a series of subnets that may communicate with each other.</p><p>The Virtual Network has a dedicated self-hosted Azure Pipelines Agent used to deploy infrastructure over the network-isolated part of the Azure Cloud. The agent is inside a subnet as well. I didn&rsquo;t represent it in the image for simplicity.</p><blockquote><p>üí° We are dealing with a high-security environment ‚Äì that&rsquo;s why we have a dedicated Azure Pipelines agent for our isolated virtual network. Without it, we would have no visibility into our services: it would be impossible to perform most operations on them, including deployments.</p></blockquote><p>We want to store our policies where our agents can easily access them. We are going to use Azure DevOps for this:</p><p><img loading=lazy src=images/opa-devops-interaction.png alt=opa-devops-interaction></p><p>There is a reason I drew dotted lines towards Docker and the Azure Storage Account: we can either store the OPA binary into a purposely-made storage account or run a Docker image to use the CLI tool. I left out the possibility of downloading the binary from Styra&rsquo;s website on purpose: if we are allowed access to the public Internet, the docker image is more ergonomic. We are already using Docker on other steps of our Azure Pipeline, so we chose to continue doing so.</p><blockquote><p>üí° In most cases, this kind of choice depends on the architectural requirements of the infrastructure (which may comprise strict security requirements). Some organizations may restrict access to public docker registries, so the storage account method should be the most secure.</p></blockquote><p>The following flowchart diagram describes the steps of our OPA-augmented provisioning pipeline:</p><p><img loading=lazy src=images/opa-flowchart.png alt=opa-flowchart></p><hr><h3 id=preparing-a-terraform-plan-to-test-our-policy-against>Preparing a Terraform plan to test our policy against<a hidden class=anchor aria-hidden=true href=#preparing-a-terraform-plan-to-test-our-policy-against>#</a></h3><p>Now that we have a clear path, it&rsquo;s time to write the policies. We will start by using this simple Terraform code that creates some resources.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-terraform data-lang=terraform><span class=line><span class=cl><span class=c1>#Azure resource group 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>resource</span> <span class=s2>&#34;azurerm_resource_group&#34;</span> <span class=s2>&#34;rg&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=na>name</span>     = <span class=nb>var</span><span class=p>.</span><span class=nx>rg_name</span>
</span></span><span class=line><span class=cl>  <span class=na>location</span> = <span class=nb>var</span><span class=p>.</span><span class=nx>location</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>
</span></span></span><span class=line><span class=cl><span class=c1>
</span></span></span><span class=line><span class=cl><span class=c1>#Azure storage account
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>resource</span> <span class=s2>&#34;azurerm_storage_account&#34;</span> <span class=s2>&#34;sa&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=na>name</span>                     = <span class=nb>var</span><span class=p>.</span><span class=nx>sa_name</span>
</span></span><span class=line><span class=cl>  <span class=na>resource_group_name</span>      = <span class=nx>azurerm_resource_group</span><span class=p>.</span><span class=nx>rg</span><span class=p>.</span><span class=nx>name</span>
</span></span><span class=line><span class=cl>  <span class=na>location</span>                 = <span class=nx>azurerm_resource_group</span><span class=p>.</span><span class=nx>rg</span><span class=p>.</span><span class=nx>location</span>
</span></span><span class=line><span class=cl>  <span class=na>account_tier</span>             = <span class=s2>&#34;Standard&#34;</span>
</span></span><span class=line><span class=cl>  <span class=na>account_replication_type</span> = <span class=s2>&#34;LRS&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>
</span></span></span><span class=line><span class=cl><span class=c1>
</span></span></span><span class=line><span class=cl><span class=c1>#Azure app service plan
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>resource</span> <span class=s2>&#34;azurerm_service_plan&#34;</span> <span class=s2>&#34;sp&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=na>sku_name</span>            = <span class=s2>&#34;Y1&#34;</span>
</span></span><span class=line><span class=cl>  <span class=na>location</span>            = <span class=nx>azurerm_resource_group</span><span class=p>.</span><span class=nx>rg</span><span class=p>.</span><span class=nx>location</span>
</span></span><span class=line><span class=cl>  <span class=na>name</span>                = <span class=nb>var</span><span class=p>.</span><span class=nx>app_service_plan_name</span>
</span></span><span class=line><span class=cl>  <span class=na>resource_group_name</span> = <span class=nx>azurerm_resource_group</span><span class=p>.</span><span class=nx>rg</span><span class=p>.</span><span class=nx>name</span>
</span></span><span class=line><span class=cl>  <span class=na>os_type</span>             = <span class=s2>&#34;Linux&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>
</span></span></span><span class=line><span class=cl><span class=kr>resource</span> <span class=s2>&#34;azurerm_linux_function_app&#34;</span> <span class=s2>&#34;fap&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=na>for_each</span>                   = <span class=nb>var</span><span class=p>.</span><span class=nx>fap_names</span>
</span></span><span class=line><span class=cl>  <span class=na>name</span>                       = <span class=nb>each</span><span class=p>.</span><span class=nx>key</span>
</span></span><span class=line><span class=cl>  <span class=na>location</span>                   = <span class=nx>azurerm_resource_group</span><span class=p>.</span><span class=nx>rg</span><span class=p>.</span><span class=nx>location</span>
</span></span><span class=line><span class=cl>  <span class=na>resource_group_name</span>        = <span class=nx>azurerm_resource_group</span><span class=p>.</span><span class=nx>rg</span><span class=p>.</span><span class=nx>name</span>
</span></span><span class=line><span class=cl>  <span class=na>service_plan_id</span>            = <span class=nx>azurerm_service_plan</span><span class=p>.</span><span class=nx>sp</span><span class=p>.</span><span class=nx>id</span>
</span></span><span class=line><span class=cl>  <span class=na>storage_account_name</span>       = <span class=nx>azurerm_storage_account</span><span class=p>.</span><span class=nx>sa</span><span class=p>.</span><span class=nx>name</span>
</span></span><span class=line><span class=cl>  <span class=na>storage_account_access_key</span> = <span class=nx>azurerm_storage_account</span><span class=p>.</span><span class=nx>sa</span><span class=p>.</span><span class=nx>primary_access_key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>site_config</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We are mainly interested in the Function Apps provisioned by the <em>azurerm_linux_function_app</em> resource. After initializing Terraform, we can use the <code>terraform plan --out=functions.tfplan</code> command to generate the binary execution plan, and then we can transform it to JSON by using <code>terraform show -json .\functions.tfplan > functions.json</code>. We are ready to write a simple naming convention policy and employ it in our plan.</p><blockquote><p>üí° I&rsquo;m referring to Terraform since that is what I&rsquo;m using at work, but the steps are 100% compatible with <a href=https://opentofu.org/>OpenTofu</a>, and I highly recommend you check out the project. I&rsquo;m using OpenTofu in place of Terraform for all my private stuff.</p></blockquote><hr><h3 id=writing-a-naming-convention-policy-for-function-apps><strong>Writing a naming convention Policy for Function Apps</strong><a hidden class=anchor aria-hidden=true href=#writing-a-naming-convention-policy-for-function-apps>#</a></h3><p>Having decided how to run our policy evaluation, we can proceed by writing a naming convention policy. I will start with a simple one. The plan is to grow the scope of the policies as I get more confidence with the Rego language.</p><p>I decided to start with a simple naming convention rule that applies to Function Apps:</p><ul><li>The name must always start with &ldquo;fap-&rdquo; which stands for Function App,</li><li>The name must always contain the three-letter abbreviation of the specific project stream we are considering. For the sake of this example, we will go with &ldquo;-prj-&rdquo;</li></ul><p>After watching this <a href="https://www.youtube.com/watch?v=wfhU72d1qqw">tutorial on integrating Terraform and OPA</a>, I decided to use some of the proposed utility functions, which you can find in the <a href=https://github.com/ned1313/learning-opa-and-terraform/blob/main/4-running-opa-exec/policies/terraform_functions.rego>repo</a> accompanying the video. In particular, I&rsquo;m using the <em>get_resources_by_type</em> utility function to filter out the resources in the Terraform plan for further analysis:</p><pre tabindex=0><code>package terraform.plan_functions

import rego.v1

# Get resources by type
get_resources_by_type(type, resources) = filtered_resources {
    filtered_resources := [resource | resource := resources[_]; resource.type = type]
}
</code></pre><p>I placed the helper functions in the <em>terraform_functions.rego</em> file.</p><blockquote><p>üí° A keen eye should spot a minor difference compared to the code in the repo: I&rsquo;ve changed the &ldquo;<em>import future.keywords</em>&rdquo; statement with <em>import rego.v1</em>. This by purpose: according to the <a href=https://www.openpolicyagent.org/docs/latest/policy-language/#future-keywords>official documentation</a> using <em>import rego.v1</em> will ensure keyword compatibility with OPA 1.0 when it releases, thus future-proofing our policies. It&rsquo;s also good to spread best practices such as this one.</p></blockquote><p>Now that we have some helper functions, we can create another file, <em>naming_policies.rego</em>:</p><pre tabindex=0><code>package general.production

import rego.v1

import data.general.naming_conventions
import data.general.plan_functions
import input.resource_changes # (1)

# Check to see if Function App is using the correct naming convention
linux_faps := plan_functions.get_resources_by_type(&#34;azurerm_linux_function_app&#34;, resource_changes) # (2)

check_fap_naming_convention(fap) if {
	name := fap.change.after.name
	startswith(name, &#34;fap-&#34;)
	contains(name, &#34;-prj-&#34;)
} # (3)

incorrect_naming_convention(resource_checks) = resources if {
	resources := [resource |
		resource := resource_checks[_]
		not check_fap_naming_convention(resource)
	] (4)
}

deny contains msg if {
	resources := incorrect_naming_convention(linux_faps)
	resources != []
	
	msg := sprintf(&#34;The following function app violates the naming convention: %s&#34;, [resources[_].address])
} (5)
</code></pre><p>I&rsquo;ll quickly go over the code: we start by importing the <em>resource_changes</em> object from our JSON-formatted Terraform plan (1) that we pass as input, and then we extract all Linux-based function apps by using the <em>get_resources_by_type</em> helper function (2). After that, we define a <em>check_fap_naming_convention</em> helper function (3) and use it in a comprehension inside the <em>incorrect_naming_convention</em> rule (4). The comprehension evaluates to the filtered array of resources which are not following our naming convention. Finally, we define a <em>deny</em> rule that generates the set of error messages, in case some of our Function Apps violate the naming convention (5). Note that the message includes the Terraform address of the resource (e.g. <em>azurerm_linux_function_app.my_fap</em>) to locate it in our Terraform code.</p><p>Don&rsquo;t worry if the code feels slightly difficult: declarative languages may seem daunting at first, but in the end, it&rsquo;s just data manipulation. I&rsquo;m getting used to the Rego language, and I&rsquo;m pretty sure my code is still not idiomatic.</p><p>I placed all the rego files inside the <em>policies</em> folder. I will pass its path as a bundle to the OPA CLI. Now it&rsquo;s time to test our policy by running opa exec locally.</p><hr><h3 id=running-the-policy-locally>Running the policy locally<a hidden class=anchor aria-hidden=true href=#running-the-policy-locally>#</a></h3><p>If you&rsquo;ve been following along, you should already have a <em>functions.json</em> plan file on which we can try to enforce our policies. In my case, I&rsquo;ve generated a plan by passing the following value to the <em>fap_names</em> variable:</p><pre tabindex=0><code>fap_names = [
  &#34;fap-prj-one&#34;,
  &#34;fap-bad-two&#34;,
  &#34;bad-prj-three&#34;
]
</code></pre><p>Functions two and three would violate the naming convention. Let&rsquo;s see our policy bundle in action.</p><p>Running the <code>opa exec --bundle .\general_policies\ --decision general/production/deny .\functions.json</code> command produces the following output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;result&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;path&#34;</span><span class=p>:</span> <span class=s2>&#34;.\\functions.json&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;result&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;The following function app violates the naming convention: azurerm_linux_function_app.fap[\&#34;bad-prj-three\&#34;]&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;The following function app violates the naming convention: azurerm_linux_function_app.fap[\&#34;fap-bad-two\&#34;]&#34;</span>
</span></span><span class=line><span class=cl>      <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The policy works! We still have to integrate it with an Azure DevOps pipeline running on a self-hosted agent. I will do that in the second part of the article, so stay tuned.</p><p>Thank you for coming this far. Power to the nerds!</p><hr><h3 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h3><p><a href=https://www.openpolicyagent.org/>Open Policy Agent</a></p><p><a href="https://marketplace.visualstudio.com/items?itemName=tsandall.opa">Open Policy Agent - Visual Studio Marketplace</a></p><p><a href=https://github.com/StyraInc/regal>StyraInc/regal: Regal is a linter for Rego, with the goal of making your Rego magnificent! (github.com)</a></p><p><a href=https://www.openpolicyagent.org/docs/latest/>Open Policy Agent | Documentation</a></p><p><a href="https://www.youtube.com/watch?v=wfhU72d1qqw">Open Policy Agent and Terraform - Using opa exec to Evaluate Policies Against an Execution Plan (youtube.com)</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://gioleppe.github.io/posts/used-books/><span class=title>¬´ Prev</span><br><span>Dirt-cheap Computer Science books</span>
</a><a class=next href=https://gioleppe.github.io/posts/summarizer-bot/><span class=title>Next ¬ª</span><br><span>How to build a Summarizer Bot using GPT4, Azure Functions, GitHub Actions</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://gioleppe.github.io/>Tommaso Colella | SWE</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>